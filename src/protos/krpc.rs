// This file is generated by rust-protobuf 2.2.2. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct ConnectionRequest {
    // message fields
    pub field_type: ConnectionRequest_Type,
    pub client_name: ::std::string::String,
    pub client_identifier: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ConnectionRequest {
    pub fn new() -> ConnectionRequest {
        ::std::default::Default::default()
    }

    // .krpc.schema.ConnectionRequest.Type type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ConnectionRequest_Type::RPC;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ConnectionRequest_Type) {
        self.field_type = v;
    }

    pub fn get_field_type(&self) -> ConnectionRequest_Type {
        self.field_type
    }

    // string client_name = 2;

    pub fn clear_client_name(&mut self) {
        self.client_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_client_name(&mut self, v: ::std::string::String) {
        self.client_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_name(&mut self) -> &mut ::std::string::String {
        &mut self.client_name
    }

    // Take field
    pub fn take_client_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.client_name, ::std::string::String::new())
    }

    pub fn get_client_name(&self) -> &str {
        &self.client_name
    }

    // bytes client_identifier = 3;

    pub fn clear_client_identifier(&mut self) {
        self.client_identifier.clear();
    }

    // Param is passed by value, moved
    pub fn set_client_identifier(&mut self, v: ::std::vec::Vec<u8>) {
        self.client_identifier = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_identifier(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.client_identifier
    }

    // Take field
    pub fn take_client_identifier(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.client_identifier, ::std::vec::Vec::new())
    }

    pub fn get_client_identifier(&self) -> &[u8] {
        &self.client_identifier
    }
}

impl ::protobuf::Message for ConnectionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.client_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.client_identifier)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != ConnectionRequest_Type::RPC {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if !self.client_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.client_name);
        }
        if !self.client_identifier.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.client_identifier);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != ConnectionRequest_Type::RPC {
            os.write_enum(1, self.field_type.value())?;
        }
        if !self.client_name.is_empty() {
            os.write_string(2, &self.client_name)?;
        }
        if !self.client_identifier.is_empty() {
            os.write_bytes(3, &self.client_identifier)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConnectionRequest {
        ConnectionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ConnectionRequest_Type>>(
                    "type",
                    |m: &ConnectionRequest| { &m.field_type },
                    |m: &mut ConnectionRequest| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "client_name",
                    |m: &ConnectionRequest| { &m.client_name },
                    |m: &mut ConnectionRequest| { &mut m.client_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "client_identifier",
                    |m: &ConnectionRequest| { &m.client_identifier },
                    |m: &mut ConnectionRequest| { &mut m.client_identifier },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConnectionRequest>(
                    "ConnectionRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConnectionRequest {
        static mut instance: ::protobuf::lazy::Lazy<ConnectionRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConnectionRequest,
        };
        unsafe {
            instance.get(ConnectionRequest::new)
        }
    }
}

impl ::protobuf::Clear for ConnectionRequest {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_client_name();
        self.clear_client_identifier();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConnectionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnectionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ConnectionRequest_Type {
    RPC = 0,
    STREAM = 1,
}

impl ::protobuf::ProtobufEnum for ConnectionRequest_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ConnectionRequest_Type> {
        match value {
            0 => ::std::option::Option::Some(ConnectionRequest_Type::RPC),
            1 => ::std::option::Option::Some(ConnectionRequest_Type::STREAM),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ConnectionRequest_Type] = &[
            ConnectionRequest_Type::RPC,
            ConnectionRequest_Type::STREAM,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ConnectionRequest_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ConnectionRequest_Type {
}

impl ::std::default::Default for ConnectionRequest_Type {
    fn default() -> Self {
        ConnectionRequest_Type::RPC
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnectionRequest_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConnectionResponse {
    // message fields
    pub status: ConnectionResponse_Status,
    pub message: ::std::string::String,
    pub client_identifier: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ConnectionResponse {
    pub fn new() -> ConnectionResponse {
        ::std::default::Default::default()
    }

    // .krpc.schema.ConnectionResponse.Status status = 1;

    pub fn clear_status(&mut self) {
        self.status = ConnectionResponse_Status::OK;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ConnectionResponse_Status) {
        self.status = v;
    }

    pub fn get_status(&self) -> ConnectionResponse_Status {
        self.status
    }

    // string message = 2;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }

    pub fn get_message(&self) -> &str {
        &self.message
    }

    // bytes client_identifier = 3;

    pub fn clear_client_identifier(&mut self) {
        self.client_identifier.clear();
    }

    // Param is passed by value, moved
    pub fn set_client_identifier(&mut self, v: ::std::vec::Vec<u8>) {
        self.client_identifier = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_identifier(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.client_identifier
    }

    // Take field
    pub fn take_client_identifier(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.client_identifier, ::std::vec::Vec::new())
    }

    pub fn get_client_identifier(&self) -> &[u8] {
        &self.client_identifier
    }
}

impl ::protobuf::Message for ConnectionResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.client_identifier)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.status != ConnectionResponse_Status::OK {
            my_size += ::protobuf::rt::enum_size(1, self.status);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        if !self.client_identifier.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.client_identifier);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.status != ConnectionResponse_Status::OK {
            os.write_enum(1, self.status.value())?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        if !self.client_identifier.is_empty() {
            os.write_bytes(3, &self.client_identifier)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConnectionResponse {
        ConnectionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ConnectionResponse_Status>>(
                    "status",
                    |m: &ConnectionResponse| { &m.status },
                    |m: &mut ConnectionResponse| { &mut m.status },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &ConnectionResponse| { &m.message },
                    |m: &mut ConnectionResponse| { &mut m.message },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "client_identifier",
                    |m: &ConnectionResponse| { &m.client_identifier },
                    |m: &mut ConnectionResponse| { &mut m.client_identifier },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ConnectionResponse>(
                    "ConnectionResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ConnectionResponse {
        static mut instance: ::protobuf::lazy::Lazy<ConnectionResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ConnectionResponse,
        };
        unsafe {
            instance.get(ConnectionResponse::new)
        }
    }
}

impl ::protobuf::Clear for ConnectionResponse {
    fn clear(&mut self) {
        self.clear_status();
        self.clear_message();
        self.clear_client_identifier();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConnectionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnectionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ConnectionResponse_Status {
    OK = 0,
    MALFORMED_MESSAGE = 1,
    TIMEOUT = 2,
    WRONG_TYPE = 3,
}

impl ::protobuf::ProtobufEnum for ConnectionResponse_Status {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ConnectionResponse_Status> {
        match value {
            0 => ::std::option::Option::Some(ConnectionResponse_Status::OK),
            1 => ::std::option::Option::Some(ConnectionResponse_Status::MALFORMED_MESSAGE),
            2 => ::std::option::Option::Some(ConnectionResponse_Status::TIMEOUT),
            3 => ::std::option::Option::Some(ConnectionResponse_Status::WRONG_TYPE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ConnectionResponse_Status] = &[
            ConnectionResponse_Status::OK,
            ConnectionResponse_Status::MALFORMED_MESSAGE,
            ConnectionResponse_Status::TIMEOUT,
            ConnectionResponse_Status::WRONG_TYPE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ConnectionResponse_Status", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ConnectionResponse_Status {
}

impl ::std::default::Default for ConnectionResponse_Status {
    fn default() -> Self {
        ConnectionResponse_Status::OK
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnectionResponse_Status {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Request {
    // message fields
    pub calls: ::protobuf::RepeatedField<ProcedureCall>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Request {
    pub fn new() -> Request {
        ::std::default::Default::default()
    }

    // repeated .krpc.schema.ProcedureCall calls = 1;

    pub fn clear_calls(&mut self) {
        self.calls.clear();
    }

    // Param is passed by value, moved
    pub fn set_calls(&mut self, v: ::protobuf::RepeatedField<ProcedureCall>) {
        self.calls = v;
    }

    // Mutable pointer to the field.
    pub fn mut_calls(&mut self) -> &mut ::protobuf::RepeatedField<ProcedureCall> {
        &mut self.calls
    }

    // Take field
    pub fn take_calls(&mut self) -> ::protobuf::RepeatedField<ProcedureCall> {
        ::std::mem::replace(&mut self.calls, ::protobuf::RepeatedField::new())
    }

    pub fn get_calls(&self) -> &[ProcedureCall] {
        &self.calls
    }
}

impl ::protobuf::Message for Request {
    fn is_initialized(&self) -> bool {
        for v in &self.calls {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.calls)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.calls {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.calls {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Request {
        Request::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProcedureCall>>(
                    "calls",
                    |m: &Request| { &m.calls },
                    |m: &mut Request| { &mut m.calls },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Request>(
                    "Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Request {
        static mut instance: ::protobuf::lazy::Lazy<Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Request,
        };
        unsafe {
            instance.get(Request::new)
        }
    }
}

impl ::protobuf::Clear for Request {
    fn clear(&mut self) {
        self.clear_calls();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Request {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ProcedureCall {
    // message fields
    pub service: ::std::string::String,
    pub procedure: ::std::string::String,
    pub service_id: u32,
    pub procedure_id: u32,
    pub arguments: ::protobuf::RepeatedField<Argument>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ProcedureCall {
    pub fn new() -> ProcedureCall {
        ::std::default::Default::default()
    }

    // string service = 1;

    pub fn clear_service(&mut self) {
        self.service.clear();
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: ::std::string::String) {
        self.service = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service(&mut self) -> &mut ::std::string::String {
        &mut self.service
    }

    // Take field
    pub fn take_service(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service, ::std::string::String::new())
    }

    pub fn get_service(&self) -> &str {
        &self.service
    }

    // string procedure = 2;

    pub fn clear_procedure(&mut self) {
        self.procedure.clear();
    }

    // Param is passed by value, moved
    pub fn set_procedure(&mut self, v: ::std::string::String) {
        self.procedure = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_procedure(&mut self) -> &mut ::std::string::String {
        &mut self.procedure
    }

    // Take field
    pub fn take_procedure(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.procedure, ::std::string::String::new())
    }

    pub fn get_procedure(&self) -> &str {
        &self.procedure
    }

    // uint32 service_id = 4;

    pub fn clear_service_id(&mut self) {
        self.service_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_service_id(&mut self, v: u32) {
        self.service_id = v;
    }

    pub fn get_service_id(&self) -> u32 {
        self.service_id
    }

    // uint32 procedure_id = 5;

    pub fn clear_procedure_id(&mut self) {
        self.procedure_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_procedure_id(&mut self, v: u32) {
        self.procedure_id = v;
    }

    pub fn get_procedure_id(&self) -> u32 {
        self.procedure_id
    }

    // repeated .krpc.schema.Argument arguments = 3;

    pub fn clear_arguments(&mut self) {
        self.arguments.clear();
    }

    // Param is passed by value, moved
    pub fn set_arguments(&mut self, v: ::protobuf::RepeatedField<Argument>) {
        self.arguments = v;
    }

    // Mutable pointer to the field.
    pub fn mut_arguments(&mut self) -> &mut ::protobuf::RepeatedField<Argument> {
        &mut self.arguments
    }

    // Take field
    pub fn take_arguments(&mut self) -> ::protobuf::RepeatedField<Argument> {
        ::std::mem::replace(&mut self.arguments, ::protobuf::RepeatedField::new())
    }

    pub fn get_arguments(&self) -> &[Argument] {
        &self.arguments
    }
}

impl ::protobuf::Message for ProcedureCall {
    fn is_initialized(&self) -> bool {
        for v in &self.arguments {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.procedure)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.service_id = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.procedure_id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.arguments)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.service.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service);
        }
        if !self.procedure.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.procedure);
        }
        if self.service_id != 0 {
            my_size += ::protobuf::rt::value_size(4, self.service_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.procedure_id != 0 {
            my_size += ::protobuf::rt::value_size(5, self.procedure_id, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.arguments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.service.is_empty() {
            os.write_string(1, &self.service)?;
        }
        if !self.procedure.is_empty() {
            os.write_string(2, &self.procedure)?;
        }
        if self.service_id != 0 {
            os.write_uint32(4, self.service_id)?;
        }
        if self.procedure_id != 0 {
            os.write_uint32(5, self.procedure_id)?;
        }
        for v in &self.arguments {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProcedureCall {
        ProcedureCall::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "service",
                    |m: &ProcedureCall| { &m.service },
                    |m: &mut ProcedureCall| { &mut m.service },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "procedure",
                    |m: &ProcedureCall| { &m.procedure },
                    |m: &mut ProcedureCall| { &mut m.procedure },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "service_id",
                    |m: &ProcedureCall| { &m.service_id },
                    |m: &mut ProcedureCall| { &mut m.service_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "procedure_id",
                    |m: &ProcedureCall| { &m.procedure_id },
                    |m: &mut ProcedureCall| { &mut m.procedure_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Argument>>(
                    "arguments",
                    |m: &ProcedureCall| { &m.arguments },
                    |m: &mut ProcedureCall| { &mut m.arguments },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ProcedureCall>(
                    "ProcedureCall",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ProcedureCall {
        static mut instance: ::protobuf::lazy::Lazy<ProcedureCall> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ProcedureCall,
        };
        unsafe {
            instance.get(ProcedureCall::new)
        }
    }
}

impl ::protobuf::Clear for ProcedureCall {
    fn clear(&mut self) {
        self.clear_service();
        self.clear_procedure();
        self.clear_service_id();
        self.clear_procedure_id();
        self.clear_arguments();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProcedureCall {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProcedureCall {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Argument {
    // message fields
    pub position: u32,
    pub value: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Argument {
    pub fn new() -> Argument {
        ::std::default::Default::default()
    }

    // uint32 position = 1;

    pub fn clear_position(&mut self) {
        self.position = 0;
    }

    // Param is passed by value, moved
    pub fn set_position(&mut self, v: u32) {
        self.position = v;
    }

    pub fn get_position(&self) -> u32 {
        self.position
    }

    // bytes value = 2;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }

    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
}

impl ::protobuf::Message for Argument {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.position = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.position != 0 {
            my_size += ::protobuf::rt::value_size(1, self.position, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.position != 0 {
            os.write_uint32(1, self.position)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(2, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Argument {
        Argument::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "position",
                    |m: &Argument| { &m.position },
                    |m: &mut Argument| { &mut m.position },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "value",
                    |m: &Argument| { &m.value },
                    |m: &mut Argument| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Argument>(
                    "Argument",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Argument {
        static mut instance: ::protobuf::lazy::Lazy<Argument> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Argument,
        };
        unsafe {
            instance.get(Argument::new)
        }
    }
}

impl ::protobuf::Clear for Argument {
    fn clear(&mut self) {
        self.clear_position();
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Argument {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Argument {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Response {
    // message fields
    pub error: ::protobuf::SingularPtrField<Error>,
    pub results: ::protobuf::RepeatedField<ProcedureResult>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Response {
    pub fn new() -> Response {
        ::std::default::Default::default()
    }

    // .krpc.schema.Error error = 1;

    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: Error) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut Error {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> Error {
        self.error.take().unwrap_or_else(|| Error::new())
    }

    pub fn get_error(&self) -> &Error {
        self.error.as_ref().unwrap_or_else(|| Error::default_instance())
    }

    // repeated .krpc.schema.ProcedureResult results = 2;

    pub fn clear_results(&mut self) {
        self.results.clear();
    }

    // Param is passed by value, moved
    pub fn set_results(&mut self, v: ::protobuf::RepeatedField<ProcedureResult>) {
        self.results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_results(&mut self) -> &mut ::protobuf::RepeatedField<ProcedureResult> {
        &mut self.results
    }

    // Take field
    pub fn take_results(&mut self) -> ::protobuf::RepeatedField<ProcedureResult> {
        ::std::mem::replace(&mut self.results, ::protobuf::RepeatedField::new())
    }

    pub fn get_results(&self) -> &[ProcedureResult] {
        &self.results
    }
}

impl ::protobuf::Message for Response {
    fn is_initialized(&self) -> bool {
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.results {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.results)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.results {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response {
        Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Error>>(
                    "error",
                    |m: &Response| { &m.error },
                    |m: &mut Response| { &mut m.error },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProcedureResult>>(
                    "results",
                    |m: &Response| { &m.results },
                    |m: &mut Response| { &mut m.results },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Response>(
                    "Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Response {
        static mut instance: ::protobuf::lazy::Lazy<Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Response,
        };
        unsafe {
            instance.get(Response::new)
        }
    }
}

impl ::protobuf::Clear for Response {
    fn clear(&mut self) {
        self.clear_error();
        self.clear_results();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ProcedureResult {
    // message fields
    pub error: ::protobuf::SingularPtrField<Error>,
    pub value: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ProcedureResult {
    pub fn new() -> ProcedureResult {
        ::std::default::Default::default()
    }

    // .krpc.schema.Error error = 1;

    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: Error) {
        self.error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut Error {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> Error {
        self.error.take().unwrap_or_else(|| Error::new())
    }

    pub fn get_error(&self) -> &Error {
        self.error.as_ref().unwrap_or_else(|| Error::default_instance())
    }

    // bytes value = 2;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }

    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
}

impl ::protobuf::Message for ProcedureResult {
    fn is_initialized(&self) -> bool {
        for v in &self.error {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.error.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(2, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProcedureResult {
        ProcedureResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Error>>(
                    "error",
                    |m: &ProcedureResult| { &m.error },
                    |m: &mut ProcedureResult| { &mut m.error },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "value",
                    |m: &ProcedureResult| { &m.value },
                    |m: &mut ProcedureResult| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ProcedureResult>(
                    "ProcedureResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ProcedureResult {
        static mut instance: ::protobuf::lazy::Lazy<ProcedureResult> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ProcedureResult,
        };
        unsafe {
            instance.get(ProcedureResult::new)
        }
    }
}

impl ::protobuf::Clear for ProcedureResult {
    fn clear(&mut self) {
        self.clear_error();
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProcedureResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProcedureResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Error {
    // message fields
    pub service: ::std::string::String,
    pub name: ::std::string::String,
    pub description: ::std::string::String,
    pub stack_trace: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Error {
    pub fn new() -> Error {
        ::std::default::Default::default()
    }

    // string service = 1;

    pub fn clear_service(&mut self) {
        self.service.clear();
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: ::std::string::String) {
        self.service = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service(&mut self) -> &mut ::std::string::String {
        &mut self.service
    }

    // Take field
    pub fn take_service(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service, ::std::string::String::new())
    }

    pub fn get_service(&self) -> &str {
        &self.service
    }

    // string name = 2;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        &self.name
    }

    // string description = 3;

    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    pub fn get_description(&self) -> &str {
        &self.description
    }

    // string stack_trace = 4;

    pub fn clear_stack_trace(&mut self) {
        self.stack_trace.clear();
    }

    // Param is passed by value, moved
    pub fn set_stack_trace(&mut self, v: ::std::string::String) {
        self.stack_trace = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stack_trace(&mut self) -> &mut ::std::string::String {
        &mut self.stack_trace
    }

    // Take field
    pub fn take_stack_trace(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.stack_trace, ::std::string::String::new())
    }

    pub fn get_stack_trace(&self) -> &str {
        &self.stack_trace
    }
}

impl ::protobuf::Message for Error {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.stack_trace)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.service.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.description);
        }
        if !self.stack_trace.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.stack_trace);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.service.is_empty() {
            os.write_string(1, &self.service)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(3, &self.description)?;
        }
        if !self.stack_trace.is_empty() {
            os.write_string(4, &self.stack_trace)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Error {
        Error::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "service",
                    |m: &Error| { &m.service },
                    |m: &mut Error| { &mut m.service },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Error| { &m.name },
                    |m: &mut Error| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "description",
                    |m: &Error| { &m.description },
                    |m: &mut Error| { &mut m.description },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "stack_trace",
                    |m: &Error| { &m.stack_trace },
                    |m: &mut Error| { &mut m.stack_trace },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Error>(
                    "Error",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Error {
        static mut instance: ::protobuf::lazy::Lazy<Error> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Error,
        };
        unsafe {
            instance.get(Error::new)
        }
    }
}

impl ::protobuf::Clear for Error {
    fn clear(&mut self) {
        self.clear_service();
        self.clear_name();
        self.clear_description();
        self.clear_stack_trace();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Error {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Error {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StreamUpdate {
    // message fields
    pub results: ::protobuf::RepeatedField<StreamResult>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl StreamUpdate {
    pub fn new() -> StreamUpdate {
        ::std::default::Default::default()
    }

    // repeated .krpc.schema.StreamResult results = 1;

    pub fn clear_results(&mut self) {
        self.results.clear();
    }

    // Param is passed by value, moved
    pub fn set_results(&mut self, v: ::protobuf::RepeatedField<StreamResult>) {
        self.results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_results(&mut self) -> &mut ::protobuf::RepeatedField<StreamResult> {
        &mut self.results
    }

    // Take field
    pub fn take_results(&mut self) -> ::protobuf::RepeatedField<StreamResult> {
        ::std::mem::replace(&mut self.results, ::protobuf::RepeatedField::new())
    }

    pub fn get_results(&self) -> &[StreamResult] {
        &self.results
    }
}

impl ::protobuf::Message for StreamUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.results {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.results)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.results {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamUpdate {
        StreamUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StreamResult>>(
                    "results",
                    |m: &StreamUpdate| { &m.results },
                    |m: &mut StreamUpdate| { &mut m.results },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StreamUpdate>(
                    "StreamUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StreamUpdate {
        static mut instance: ::protobuf::lazy::Lazy<StreamUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StreamUpdate,
        };
        unsafe {
            instance.get(StreamUpdate::new)
        }
    }
}

impl ::protobuf::Clear for StreamUpdate {
    fn clear(&mut self) {
        self.clear_results();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StreamUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StreamResult {
    // message fields
    pub id: u64,
    pub result: ::protobuf::SingularPtrField<ProcedureResult>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl StreamResult {
    pub fn new() -> StreamResult {
        ::std::default::Default::default()
    }

    // uint64 id = 1;

    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = v;
    }

    pub fn get_id(&self) -> u64 {
        self.id
    }

    // .krpc.schema.ProcedureResult result = 2;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: ProcedureResult) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut ProcedureResult {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> ProcedureResult {
        self.result.take().unwrap_or_else(|| ProcedureResult::new())
    }

    pub fn get_result(&self) -> &ProcedureResult {
        self.result.as_ref().unwrap_or_else(|| ProcedureResult::default_instance())
    }
}

impl ::protobuf::Message for StreamResult {
    fn is_initialized(&self) -> bool {
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_uint64(1, self.id)?;
        }
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StreamResult {
        StreamResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "id",
                    |m: &StreamResult| { &m.id },
                    |m: &mut StreamResult| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProcedureResult>>(
                    "result",
                    |m: &StreamResult| { &m.result },
                    |m: &mut StreamResult| { &mut m.result },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StreamResult>(
                    "StreamResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StreamResult {
        static mut instance: ::protobuf::lazy::Lazy<StreamResult> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StreamResult,
        };
        unsafe {
            instance.get(StreamResult::new)
        }
    }
}

impl ::protobuf::Clear for StreamResult {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StreamResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Services {
    // message fields
    pub services: ::protobuf::RepeatedField<Service>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Services {
    pub fn new() -> Services {
        ::std::default::Default::default()
    }

    // repeated .krpc.schema.Service services = 1;

    pub fn clear_services(&mut self) {
        self.services.clear();
    }

    // Param is passed by value, moved
    pub fn set_services(&mut self, v: ::protobuf::RepeatedField<Service>) {
        self.services = v;
    }

    // Mutable pointer to the field.
    pub fn mut_services(&mut self) -> &mut ::protobuf::RepeatedField<Service> {
        &mut self.services
    }

    // Take field
    pub fn take_services(&mut self) -> ::protobuf::RepeatedField<Service> {
        ::std::mem::replace(&mut self.services, ::protobuf::RepeatedField::new())
    }

    pub fn get_services(&self) -> &[Service] {
        &self.services
    }
}

impl ::protobuf::Message for Services {
    fn is_initialized(&self) -> bool {
        for v in &self.services {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.services)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.services {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.services {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Services {
        Services::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Service>>(
                    "services",
                    |m: &Services| { &m.services },
                    |m: &mut Services| { &mut m.services },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Services>(
                    "Services",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Services {
        static mut instance: ::protobuf::lazy::Lazy<Services> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Services,
        };
        unsafe {
            instance.get(Services::new)
        }
    }
}

impl ::protobuf::Clear for Services {
    fn clear(&mut self) {
        self.clear_services();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Services {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Services {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Service {
    // message fields
    pub name: ::std::string::String,
    pub procedures: ::protobuf::RepeatedField<Procedure>,
    pub classes: ::protobuf::RepeatedField<Class>,
    pub enumerations: ::protobuf::RepeatedField<Enumeration>,
    pub exceptions: ::protobuf::RepeatedField<Exception>,
    pub documentation: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Service {
    pub fn new() -> Service {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        &self.name
    }

    // repeated .krpc.schema.Procedure procedures = 2;

    pub fn clear_procedures(&mut self) {
        self.procedures.clear();
    }

    // Param is passed by value, moved
    pub fn set_procedures(&mut self, v: ::protobuf::RepeatedField<Procedure>) {
        self.procedures = v;
    }

    // Mutable pointer to the field.
    pub fn mut_procedures(&mut self) -> &mut ::protobuf::RepeatedField<Procedure> {
        &mut self.procedures
    }

    // Take field
    pub fn take_procedures(&mut self) -> ::protobuf::RepeatedField<Procedure> {
        ::std::mem::replace(&mut self.procedures, ::protobuf::RepeatedField::new())
    }

    pub fn get_procedures(&self) -> &[Procedure] {
        &self.procedures
    }

    // repeated .krpc.schema.Class classes = 3;

    pub fn clear_classes(&mut self) {
        self.classes.clear();
    }

    // Param is passed by value, moved
    pub fn set_classes(&mut self, v: ::protobuf::RepeatedField<Class>) {
        self.classes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_classes(&mut self) -> &mut ::protobuf::RepeatedField<Class> {
        &mut self.classes
    }

    // Take field
    pub fn take_classes(&mut self) -> ::protobuf::RepeatedField<Class> {
        ::std::mem::replace(&mut self.classes, ::protobuf::RepeatedField::new())
    }

    pub fn get_classes(&self) -> &[Class] {
        &self.classes
    }

    // repeated .krpc.schema.Enumeration enumerations = 4;

    pub fn clear_enumerations(&mut self) {
        self.enumerations.clear();
    }

    // Param is passed by value, moved
    pub fn set_enumerations(&mut self, v: ::protobuf::RepeatedField<Enumeration>) {
        self.enumerations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_enumerations(&mut self) -> &mut ::protobuf::RepeatedField<Enumeration> {
        &mut self.enumerations
    }

    // Take field
    pub fn take_enumerations(&mut self) -> ::protobuf::RepeatedField<Enumeration> {
        ::std::mem::replace(&mut self.enumerations, ::protobuf::RepeatedField::new())
    }

    pub fn get_enumerations(&self) -> &[Enumeration] {
        &self.enumerations
    }

    // repeated .krpc.schema.Exception exceptions = 5;

    pub fn clear_exceptions(&mut self) {
        self.exceptions.clear();
    }

    // Param is passed by value, moved
    pub fn set_exceptions(&mut self, v: ::protobuf::RepeatedField<Exception>) {
        self.exceptions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_exceptions(&mut self) -> &mut ::protobuf::RepeatedField<Exception> {
        &mut self.exceptions
    }

    // Take field
    pub fn take_exceptions(&mut self) -> ::protobuf::RepeatedField<Exception> {
        ::std::mem::replace(&mut self.exceptions, ::protobuf::RepeatedField::new())
    }

    pub fn get_exceptions(&self) -> &[Exception] {
        &self.exceptions
    }

    // string documentation = 6;

    pub fn clear_documentation(&mut self) {
        self.documentation.clear();
    }

    // Param is passed by value, moved
    pub fn set_documentation(&mut self, v: ::std::string::String) {
        self.documentation = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_documentation(&mut self) -> &mut ::std::string::String {
        &mut self.documentation
    }

    // Take field
    pub fn take_documentation(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.documentation, ::std::string::String::new())
    }

    pub fn get_documentation(&self) -> &str {
        &self.documentation
    }
}

impl ::protobuf::Message for Service {
    fn is_initialized(&self) -> bool {
        for v in &self.procedures {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.classes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.enumerations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.exceptions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.procedures)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.classes)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.enumerations)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.exceptions)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.documentation)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        for value in &self.procedures {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.classes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.enumerations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.exceptions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.documentation.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.documentation);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        for v in &self.procedures {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.classes {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.enumerations {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.exceptions {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.documentation.is_empty() {
            os.write_string(6, &self.documentation)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Service {
        Service::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Service| { &m.name },
                    |m: &mut Service| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Procedure>>(
                    "procedures",
                    |m: &Service| { &m.procedures },
                    |m: &mut Service| { &mut m.procedures },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Class>>(
                    "classes",
                    |m: &Service| { &m.classes },
                    |m: &mut Service| { &mut m.classes },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Enumeration>>(
                    "enumerations",
                    |m: &Service| { &m.enumerations },
                    |m: &mut Service| { &mut m.enumerations },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Exception>>(
                    "exceptions",
                    |m: &Service| { &m.exceptions },
                    |m: &mut Service| { &mut m.exceptions },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "documentation",
                    |m: &Service| { &m.documentation },
                    |m: &mut Service| { &mut m.documentation },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Service>(
                    "Service",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Service {
        static mut instance: ::protobuf::lazy::Lazy<Service> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Service,
        };
        unsafe {
            instance.get(Service::new)
        }
    }
}

impl ::protobuf::Clear for Service {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_procedures();
        self.clear_classes();
        self.clear_enumerations();
        self.clear_exceptions();
        self.clear_documentation();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Service {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Service {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Procedure {
    // message fields
    pub name: ::std::string::String,
    pub parameters: ::protobuf::RepeatedField<Parameter>,
    pub return_type: ::protobuf::SingularPtrField<Type>,
    pub return_is_nullable: bool,
    pub game_scenes: ::std::vec::Vec<Procedure_GameScene>,
    pub documentation: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Procedure {
    pub fn new() -> Procedure {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        &self.name
    }

    // repeated .krpc.schema.Parameter parameters = 2;

    pub fn clear_parameters(&mut self) {
        self.parameters.clear();
    }

    // Param is passed by value, moved
    pub fn set_parameters(&mut self, v: ::protobuf::RepeatedField<Parameter>) {
        self.parameters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_parameters(&mut self) -> &mut ::protobuf::RepeatedField<Parameter> {
        &mut self.parameters
    }

    // Take field
    pub fn take_parameters(&mut self) -> ::protobuf::RepeatedField<Parameter> {
        ::std::mem::replace(&mut self.parameters, ::protobuf::RepeatedField::new())
    }

    pub fn get_parameters(&self) -> &[Parameter] {
        &self.parameters
    }

    // .krpc.schema.Type return_type = 3;

    pub fn clear_return_type(&mut self) {
        self.return_type.clear();
    }

    pub fn has_return_type(&self) -> bool {
        self.return_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_return_type(&mut self, v: Type) {
        self.return_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_return_type(&mut self) -> &mut Type {
        if self.return_type.is_none() {
            self.return_type.set_default();
        }
        self.return_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_return_type(&mut self) -> Type {
        self.return_type.take().unwrap_or_else(|| Type::new())
    }

    pub fn get_return_type(&self) -> &Type {
        self.return_type.as_ref().unwrap_or_else(|| Type::default_instance())
    }

    // bool return_is_nullable = 4;

    pub fn clear_return_is_nullable(&mut self) {
        self.return_is_nullable = false;
    }

    // Param is passed by value, moved
    pub fn set_return_is_nullable(&mut self, v: bool) {
        self.return_is_nullable = v;
    }

    pub fn get_return_is_nullable(&self) -> bool {
        self.return_is_nullable
    }

    // repeated .krpc.schema.Procedure.GameScene game_scenes = 6;

    pub fn clear_game_scenes(&mut self) {
        self.game_scenes.clear();
    }

    // Param is passed by value, moved
    pub fn set_game_scenes(&mut self, v: ::std::vec::Vec<Procedure_GameScene>) {
        self.game_scenes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_game_scenes(&mut self) -> &mut ::std::vec::Vec<Procedure_GameScene> {
        &mut self.game_scenes
    }

    // Take field
    pub fn take_game_scenes(&mut self) -> ::std::vec::Vec<Procedure_GameScene> {
        ::std::mem::replace(&mut self.game_scenes, ::std::vec::Vec::new())
    }

    pub fn get_game_scenes(&self) -> &[Procedure_GameScene] {
        &self.game_scenes
    }

    // string documentation = 5;

    pub fn clear_documentation(&mut self) {
        self.documentation.clear();
    }

    // Param is passed by value, moved
    pub fn set_documentation(&mut self, v: ::std::string::String) {
        self.documentation = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_documentation(&mut self) -> &mut ::std::string::String {
        &mut self.documentation
    }

    // Take field
    pub fn take_documentation(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.documentation, ::std::string::String::new())
    }

    pub fn get_documentation(&self) -> &str {
        &self.documentation
    }
}

impl ::protobuf::Message for Procedure {
    fn is_initialized(&self) -> bool {
        for v in &self.parameters {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.return_type {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.parameters)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.return_type)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.return_is_nullable = tmp;
                },
                6 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.game_scenes, 6, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.documentation)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        for value in &self.parameters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.return_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.return_is_nullable != false {
            my_size += 2;
        }
        for value in &self.game_scenes {
            my_size += ::protobuf::rt::enum_size(6, *value);
        };
        if !self.documentation.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.documentation);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        for v in &self.parameters {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.return_type.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.return_is_nullable != false {
            os.write_bool(4, self.return_is_nullable)?;
        }
        for v in &self.game_scenes {
            os.write_enum(6, v.value())?;
        };
        if !self.documentation.is_empty() {
            os.write_string(5, &self.documentation)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Procedure {
        Procedure::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Procedure| { &m.name },
                    |m: &mut Procedure| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Parameter>>(
                    "parameters",
                    |m: &Procedure| { &m.parameters },
                    |m: &mut Procedure| { &mut m.parameters },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "return_type",
                    |m: &Procedure| { &m.return_type },
                    |m: &mut Procedure| { &mut m.return_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "return_is_nullable",
                    |m: &Procedure| { &m.return_is_nullable },
                    |m: &mut Procedure| { &mut m.return_is_nullable },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Procedure_GameScene>>(
                    "game_scenes",
                    |m: &Procedure| { &m.game_scenes },
                    |m: &mut Procedure| { &mut m.game_scenes },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "documentation",
                    |m: &Procedure| { &m.documentation },
                    |m: &mut Procedure| { &mut m.documentation },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Procedure>(
                    "Procedure",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Procedure {
        static mut instance: ::protobuf::lazy::Lazy<Procedure> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Procedure,
        };
        unsafe {
            instance.get(Procedure::new)
        }
    }
}

impl ::protobuf::Clear for Procedure {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_parameters();
        self.clear_return_type();
        self.clear_return_is_nullable();
        self.clear_game_scenes();
        self.clear_documentation();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Procedure {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Procedure {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Procedure_GameScene {
    SPACE_CENTER = 0,
    FLIGHT = 1,
    TRACKING_STATION = 2,
    EDITOR_VAB = 3,
    EDITOR_SPH = 4,
    MISSION_BUILDER = 5,
}

impl ::protobuf::ProtobufEnum for Procedure_GameScene {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Procedure_GameScene> {
        match value {
            0 => ::std::option::Option::Some(Procedure_GameScene::SPACE_CENTER),
            1 => ::std::option::Option::Some(Procedure_GameScene::FLIGHT),
            2 => ::std::option::Option::Some(Procedure_GameScene::TRACKING_STATION),
            3 => ::std::option::Option::Some(Procedure_GameScene::EDITOR_VAB),
            4 => ::std::option::Option::Some(Procedure_GameScene::EDITOR_SPH),
            5 => ::std::option::Option::Some(Procedure_GameScene::MISSION_BUILDER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Procedure_GameScene] = &[
            Procedure_GameScene::SPACE_CENTER,
            Procedure_GameScene::FLIGHT,
            Procedure_GameScene::TRACKING_STATION,
            Procedure_GameScene::EDITOR_VAB,
            Procedure_GameScene::EDITOR_SPH,
            Procedure_GameScene::MISSION_BUILDER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Procedure_GameScene", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Procedure_GameScene {
}

impl ::std::default::Default for Procedure_GameScene {
    fn default() -> Self {
        Procedure_GameScene::SPACE_CENTER
    }
}

impl ::protobuf::reflect::ProtobufValue for Procedure_GameScene {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Parameter {
    // message fields
    pub name: ::std::string::String,
    pub field_type: ::protobuf::SingularPtrField<Type>,
    pub default_value: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Parameter {
    pub fn new() -> Parameter {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        &self.name
    }

    // .krpc.schema.Type type = 2;

    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Type) {
        self.field_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut Type {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> Type {
        self.field_type.take().unwrap_or_else(|| Type::new())
    }

    pub fn get_field_type(&self) -> &Type {
        self.field_type.as_ref().unwrap_or_else(|| Type::default_instance())
    }

    // bytes default_value = 3;

    pub fn clear_default_value(&mut self) {
        self.default_value.clear();
    }

    // Param is passed by value, moved
    pub fn set_default_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.default_value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_default_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.default_value
    }

    // Take field
    pub fn take_default_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.default_value, ::std::vec::Vec::new())
    }

    pub fn get_default_value(&self) -> &[u8] {
        &self.default_value
    }
}

impl ::protobuf::Message for Parameter {
    fn is_initialized(&self) -> bool {
        for v in &self.field_type {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.field_type)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.default_value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let Some(ref v) = self.field_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.default_value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.default_value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.default_value.is_empty() {
            os.write_bytes(3, &self.default_value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Parameter {
        Parameter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Parameter| { &m.name },
                    |m: &mut Parameter| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "type",
                    |m: &Parameter| { &m.field_type },
                    |m: &mut Parameter| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "default_value",
                    |m: &Parameter| { &m.default_value },
                    |m: &mut Parameter| { &mut m.default_value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Parameter>(
                    "Parameter",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Parameter {
        static mut instance: ::protobuf::lazy::Lazy<Parameter> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Parameter,
        };
        unsafe {
            instance.get(Parameter::new)
        }
    }
}

impl ::protobuf::Clear for Parameter {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_field_type();
        self.clear_default_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Parameter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Parameter {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Class {
    // message fields
    pub name: ::std::string::String,
    pub documentation: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Class {
    pub fn new() -> Class {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        &self.name
    }

    // string documentation = 2;

    pub fn clear_documentation(&mut self) {
        self.documentation.clear();
    }

    // Param is passed by value, moved
    pub fn set_documentation(&mut self, v: ::std::string::String) {
        self.documentation = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_documentation(&mut self) -> &mut ::std::string::String {
        &mut self.documentation
    }

    // Take field
    pub fn take_documentation(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.documentation, ::std::string::String::new())
    }

    pub fn get_documentation(&self) -> &str {
        &self.documentation
    }
}

impl ::protobuf::Message for Class {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.documentation)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.documentation.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.documentation);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.documentation.is_empty() {
            os.write_string(2, &self.documentation)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Class {
        Class::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Class| { &m.name },
                    |m: &mut Class| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "documentation",
                    |m: &Class| { &m.documentation },
                    |m: &mut Class| { &mut m.documentation },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Class>(
                    "Class",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Class {
        static mut instance: ::protobuf::lazy::Lazy<Class> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Class,
        };
        unsafe {
            instance.get(Class::new)
        }
    }
}

impl ::protobuf::Clear for Class {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_documentation();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Class {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Class {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Enumeration {
    // message fields
    pub name: ::std::string::String,
    pub values: ::protobuf::RepeatedField<EnumerationValue>,
    pub documentation: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Enumeration {
    pub fn new() -> Enumeration {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        &self.name
    }

    // repeated .krpc.schema.EnumerationValue values = 2;

    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::protobuf::RepeatedField<EnumerationValue>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::protobuf::RepeatedField<EnumerationValue> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::protobuf::RepeatedField<EnumerationValue> {
        ::std::mem::replace(&mut self.values, ::protobuf::RepeatedField::new())
    }

    pub fn get_values(&self) -> &[EnumerationValue] {
        &self.values
    }

    // string documentation = 3;

    pub fn clear_documentation(&mut self) {
        self.documentation.clear();
    }

    // Param is passed by value, moved
    pub fn set_documentation(&mut self, v: ::std::string::String) {
        self.documentation = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_documentation(&mut self) -> &mut ::std::string::String {
        &mut self.documentation
    }

    // Take field
    pub fn take_documentation(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.documentation, ::std::string::String::new())
    }

    pub fn get_documentation(&self) -> &str {
        &self.documentation
    }
}

impl ::protobuf::Message for Enumeration {
    fn is_initialized(&self) -> bool {
        for v in &self.values {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.values)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.documentation)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        for value in &self.values {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.documentation.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.documentation);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        for v in &self.values {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.documentation.is_empty() {
            os.write_string(3, &self.documentation)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Enumeration {
        Enumeration::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Enumeration| { &m.name },
                    |m: &mut Enumeration| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EnumerationValue>>(
                    "values",
                    |m: &Enumeration| { &m.values },
                    |m: &mut Enumeration| { &mut m.values },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "documentation",
                    |m: &Enumeration| { &m.documentation },
                    |m: &mut Enumeration| { &mut m.documentation },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Enumeration>(
                    "Enumeration",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Enumeration {
        static mut instance: ::protobuf::lazy::Lazy<Enumeration> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Enumeration,
        };
        unsafe {
            instance.get(Enumeration::new)
        }
    }
}

impl ::protobuf::Clear for Enumeration {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_values();
        self.clear_documentation();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Enumeration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Enumeration {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EnumerationValue {
    // message fields
    pub name: ::std::string::String,
    pub value: i32,
    pub documentation: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl EnumerationValue {
    pub fn new() -> EnumerationValue {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        &self.name
    }

    // int32 value = 2;

    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i32) {
        self.value = v;
    }

    pub fn get_value(&self) -> i32 {
        self.value
    }

    // string documentation = 3;

    pub fn clear_documentation(&mut self) {
        self.documentation.clear();
    }

    // Param is passed by value, moved
    pub fn set_documentation(&mut self, v: ::std::string::String) {
        self.documentation = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_documentation(&mut self) -> &mut ::std::string::String {
        &mut self.documentation
    }

    // Take field
    pub fn take_documentation(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.documentation, ::std::string::String::new())
    }

    pub fn get_documentation(&self) -> &str {
        &self.documentation
    }
}

impl ::protobuf::Message for EnumerationValue {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.value = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.documentation)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(2, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.documentation.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.documentation);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.value != 0 {
            os.write_int32(2, self.value)?;
        }
        if !self.documentation.is_empty() {
            os.write_string(3, &self.documentation)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EnumerationValue {
        EnumerationValue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &EnumerationValue| { &m.name },
                    |m: &mut EnumerationValue| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "value",
                    |m: &EnumerationValue| { &m.value },
                    |m: &mut EnumerationValue| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "documentation",
                    |m: &EnumerationValue| { &m.documentation },
                    |m: &mut EnumerationValue| { &mut m.documentation },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EnumerationValue>(
                    "EnumerationValue",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EnumerationValue {
        static mut instance: ::protobuf::lazy::Lazy<EnumerationValue> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EnumerationValue,
        };
        unsafe {
            instance.get(EnumerationValue::new)
        }
    }
}

impl ::protobuf::Clear for EnumerationValue {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_value();
        self.clear_documentation();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EnumerationValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EnumerationValue {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Exception {
    // message fields
    pub name: ::std::string::String,
    pub documentation: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Exception {
    pub fn new() -> Exception {
        ::std::default::Default::default()
    }

    // string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        &self.name
    }

    // string documentation = 2;

    pub fn clear_documentation(&mut self) {
        self.documentation.clear();
    }

    // Param is passed by value, moved
    pub fn set_documentation(&mut self, v: ::std::string::String) {
        self.documentation = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_documentation(&mut self) -> &mut ::std::string::String {
        &mut self.documentation
    }

    // Take field
    pub fn take_documentation(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.documentation, ::std::string::String::new())
    }

    pub fn get_documentation(&self) -> &str {
        &self.documentation
    }
}

impl ::protobuf::Message for Exception {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.documentation)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.documentation.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.documentation);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.documentation.is_empty() {
            os.write_string(2, &self.documentation)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Exception {
        Exception::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Exception| { &m.name },
                    |m: &mut Exception| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "documentation",
                    |m: &Exception| { &m.documentation },
                    |m: &mut Exception| { &mut m.documentation },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Exception>(
                    "Exception",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Exception {
        static mut instance: ::protobuf::lazy::Lazy<Exception> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Exception,
        };
        unsafe {
            instance.get(Exception::new)
        }
    }
}

impl ::protobuf::Clear for Exception {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_documentation();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Exception {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Exception {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Type {
    // message fields
    pub code: Type_TypeCode,
    pub service: ::std::string::String,
    pub name: ::std::string::String,
    pub types: ::protobuf::RepeatedField<Type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Type {
    pub fn new() -> Type {
        ::std::default::Default::default()
    }

    // .krpc.schema.Type.TypeCode code = 1;

    pub fn clear_code(&mut self) {
        self.code = Type_TypeCode::NONE;
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: Type_TypeCode) {
        self.code = v;
    }

    pub fn get_code(&self) -> Type_TypeCode {
        self.code
    }

    // string service = 2;

    pub fn clear_service(&mut self) {
        self.service.clear();
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: ::std::string::String) {
        self.service = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service(&mut self) -> &mut ::std::string::String {
        &mut self.service
    }

    // Take field
    pub fn take_service(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service, ::std::string::String::new())
    }

    pub fn get_service(&self) -> &str {
        &self.service
    }

    // string name = 3;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    pub fn get_name(&self) -> &str {
        &self.name
    }

    // repeated .krpc.schema.Type types = 4;

    pub fn clear_types(&mut self) {
        self.types.clear();
    }

    // Param is passed by value, moved
    pub fn set_types(&mut self, v: ::protobuf::RepeatedField<Type>) {
        self.types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_types(&mut self) -> &mut ::protobuf::RepeatedField<Type> {
        &mut self.types
    }

    // Take field
    pub fn take_types(&mut self) -> ::protobuf::RepeatedField<Type> {
        ::std::mem::replace(&mut self.types, ::protobuf::RepeatedField::new())
    }

    pub fn get_types(&self) -> &[Type] {
        &self.types
    }
}

impl ::protobuf::Message for Type {
    fn is_initialized(&self) -> bool {
        for v in &self.types {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.code, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.types)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.code != Type_TypeCode::NONE {
            my_size += ::protobuf::rt::enum_size(1, self.code);
        }
        if !self.service.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.service);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        for value in &self.types {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.code != Type_TypeCode::NONE {
            os.write_enum(1, self.code.value())?;
        }
        if !self.service.is_empty() {
            os.write_string(2, &self.service)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        for v in &self.types {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Type {
        Type::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Type_TypeCode>>(
                    "code",
                    |m: &Type| { &m.code },
                    |m: &mut Type| { &mut m.code },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "service",
                    |m: &Type| { &m.service },
                    |m: &mut Type| { &mut m.service },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &Type| { &m.name },
                    |m: &mut Type| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                    "types",
                    |m: &Type| { &m.types },
                    |m: &mut Type| { &mut m.types },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Type>(
                    "Type",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Type {
        static mut instance: ::protobuf::lazy::Lazy<Type> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Type,
        };
        unsafe {
            instance.get(Type::new)
        }
    }
}

impl ::protobuf::Clear for Type {
    fn clear(&mut self) {
        self.clear_code();
        self.clear_service();
        self.clear_name();
        self.clear_types();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Type {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Type_TypeCode {
    NONE = 0,
    DOUBLE = 1,
    FLOAT = 2,
    SINT32 = 3,
    SINT64 = 4,
    UINT32 = 5,
    UINT64 = 6,
    BOOL = 7,
    STRING = 8,
    BYTES = 9,
    CLASS = 100,
    ENUMERATION = 101,
    EVENT = 200,
    PROCEDURE_CALL = 201,
    STREAM = 202,
    STATUS = 203,
    SERVICES = 204,
    TUPLE = 300,
    LIST = 301,
    SET = 302,
    DICTIONARY = 303,
}

impl ::protobuf::ProtobufEnum for Type_TypeCode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Type_TypeCode> {
        match value {
            0 => ::std::option::Option::Some(Type_TypeCode::NONE),
            1 => ::std::option::Option::Some(Type_TypeCode::DOUBLE),
            2 => ::std::option::Option::Some(Type_TypeCode::FLOAT),
            3 => ::std::option::Option::Some(Type_TypeCode::SINT32),
            4 => ::std::option::Option::Some(Type_TypeCode::SINT64),
            5 => ::std::option::Option::Some(Type_TypeCode::UINT32),
            6 => ::std::option::Option::Some(Type_TypeCode::UINT64),
            7 => ::std::option::Option::Some(Type_TypeCode::BOOL),
            8 => ::std::option::Option::Some(Type_TypeCode::STRING),
            9 => ::std::option::Option::Some(Type_TypeCode::BYTES),
            100 => ::std::option::Option::Some(Type_TypeCode::CLASS),
            101 => ::std::option::Option::Some(Type_TypeCode::ENUMERATION),
            200 => ::std::option::Option::Some(Type_TypeCode::EVENT),
            201 => ::std::option::Option::Some(Type_TypeCode::PROCEDURE_CALL),
            202 => ::std::option::Option::Some(Type_TypeCode::STREAM),
            203 => ::std::option::Option::Some(Type_TypeCode::STATUS),
            204 => ::std::option::Option::Some(Type_TypeCode::SERVICES),
            300 => ::std::option::Option::Some(Type_TypeCode::TUPLE),
            301 => ::std::option::Option::Some(Type_TypeCode::LIST),
            302 => ::std::option::Option::Some(Type_TypeCode::SET),
            303 => ::std::option::Option::Some(Type_TypeCode::DICTIONARY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Type_TypeCode] = &[
            Type_TypeCode::NONE,
            Type_TypeCode::DOUBLE,
            Type_TypeCode::FLOAT,
            Type_TypeCode::SINT32,
            Type_TypeCode::SINT64,
            Type_TypeCode::UINT32,
            Type_TypeCode::UINT64,
            Type_TypeCode::BOOL,
            Type_TypeCode::STRING,
            Type_TypeCode::BYTES,
            Type_TypeCode::CLASS,
            Type_TypeCode::ENUMERATION,
            Type_TypeCode::EVENT,
            Type_TypeCode::PROCEDURE_CALL,
            Type_TypeCode::STREAM,
            Type_TypeCode::STATUS,
            Type_TypeCode::SERVICES,
            Type_TypeCode::TUPLE,
            Type_TypeCode::LIST,
            Type_TypeCode::SET,
            Type_TypeCode::DICTIONARY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Type_TypeCode", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Type_TypeCode {
}

impl ::std::default::Default for Type_TypeCode {
    fn default() -> Self {
        Type_TypeCode::NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for Type_TypeCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Tuple {
    // message fields
    pub items: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Tuple {
    pub fn new() -> Tuple {
        ::std::default::Default::default()
    }

    // repeated bytes items = 1;

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }

    pub fn get_items(&self) -> &[::std::vec::Vec<u8>] {
        &self.items
    }
}

impl ::protobuf::Message for Tuple {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.items {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.items {
            os.write_bytes(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Tuple {
        Tuple::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "items",
                    |m: &Tuple| { &m.items },
                    |m: &mut Tuple| { &mut m.items },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Tuple>(
                    "Tuple",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Tuple {
        static mut instance: ::protobuf::lazy::Lazy<Tuple> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Tuple,
        };
        unsafe {
            instance.get(Tuple::new)
        }
    }
}

impl ::protobuf::Clear for Tuple {
    fn clear(&mut self) {
        self.clear_items();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Tuple {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Tuple {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct List {
    // message fields
    pub items: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl List {
    pub fn new() -> List {
        ::std::default::Default::default()
    }

    // repeated bytes items = 1;

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }

    pub fn get_items(&self) -> &[::std::vec::Vec<u8>] {
        &self.items
    }
}

impl ::protobuf::Message for List {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.items {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.items {
            os.write_bytes(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> List {
        List::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "items",
                    |m: &List| { &m.items },
                    |m: &mut List| { &mut m.items },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<List>(
                    "List",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static List {
        static mut instance: ::protobuf::lazy::Lazy<List> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const List,
        };
        unsafe {
            instance.get(List::new)
        }
    }
}

impl ::protobuf::Clear for List {
    fn clear(&mut self) {
        self.clear_items();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for List {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for List {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Set {
    // message fields
    pub items: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Set {
    pub fn new() -> Set {
        ::std::default::Default::default()
    }

    // repeated bytes items = 1;

    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }

    pub fn get_items(&self) -> &[::std::vec::Vec<u8>] {
        &self.items
    }
}

impl ::protobuf::Message for Set {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.items {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.items {
            os.write_bytes(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Set {
        Set::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "items",
                    |m: &Set| { &m.items },
                    |m: &mut Set| { &mut m.items },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Set>(
                    "Set",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Set {
        static mut instance: ::protobuf::lazy::Lazy<Set> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Set,
        };
        unsafe {
            instance.get(Set::new)
        }
    }
}

impl ::protobuf::Clear for Set {
    fn clear(&mut self) {
        self.clear_items();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Set {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Set {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Dictionary {
    // message fields
    pub entries: ::protobuf::RepeatedField<DictionaryEntry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Dictionary {
    pub fn new() -> Dictionary {
        ::std::default::Default::default()
    }

    // repeated .krpc.schema.DictionaryEntry entries = 1;

    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::protobuf::RepeatedField<DictionaryEntry>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::protobuf::RepeatedField<DictionaryEntry> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::protobuf::RepeatedField<DictionaryEntry> {
        ::std::mem::replace(&mut self.entries, ::protobuf::RepeatedField::new())
    }

    pub fn get_entries(&self) -> &[DictionaryEntry] {
        &self.entries
    }
}

impl ::protobuf::Message for Dictionary {
    fn is_initialized(&self) -> bool {
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entries {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Dictionary {
        Dictionary::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DictionaryEntry>>(
                    "entries",
                    |m: &Dictionary| { &m.entries },
                    |m: &mut Dictionary| { &mut m.entries },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Dictionary>(
                    "Dictionary",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Dictionary {
        static mut instance: ::protobuf::lazy::Lazy<Dictionary> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Dictionary,
        };
        unsafe {
            instance.get(Dictionary::new)
        }
    }
}

impl ::protobuf::Clear for Dictionary {
    fn clear(&mut self) {
        self.clear_entries();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Dictionary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Dictionary {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DictionaryEntry {
    // message fields
    pub key: ::std::vec::Vec<u8>,
    pub value: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl DictionaryEntry {
    pub fn new() -> DictionaryEntry {
        ::std::default::Default::default()
    }

    // bytes key = 1;

    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }

    pub fn get_key(&self) -> &[u8] {
        &self.key
    }

    // bytes value = 2;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }

    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
}

impl ::protobuf::Message for DictionaryEntry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_bytes(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(2, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DictionaryEntry {
        DictionaryEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "key",
                    |m: &DictionaryEntry| { &m.key },
                    |m: &mut DictionaryEntry| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "value",
                    |m: &DictionaryEntry| { &m.value },
                    |m: &mut DictionaryEntry| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DictionaryEntry>(
                    "DictionaryEntry",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DictionaryEntry {
        static mut instance: ::protobuf::lazy::Lazy<DictionaryEntry> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DictionaryEntry,
        };
        unsafe {
            instance.get(DictionaryEntry::new)
        }
    }
}

impl ::protobuf::Clear for DictionaryEntry {
    fn clear(&mut self) {
        self.clear_key();
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DictionaryEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DictionaryEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Stream {
    // message fields
    pub id: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Stream {
    pub fn new() -> Stream {
        ::std::default::Default::default()
    }

    // uint64 id = 1;

    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = v;
    }

    pub fn get_id(&self) -> u64 {
        self.id
    }
}

impl ::protobuf::Message for Stream {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_uint64(1, self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Stream {
        Stream::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "id",
                    |m: &Stream| { &m.id },
                    |m: &mut Stream| { &mut m.id },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Stream>(
                    "Stream",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Stream {
        static mut instance: ::protobuf::lazy::Lazy<Stream> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Stream,
        };
        unsafe {
            instance.get(Stream::new)
        }
    }
}

impl ::protobuf::Clear for Stream {
    fn clear(&mut self) {
        self.clear_id();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Stream {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Stream {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Event {
    // message fields
    pub stream: ::protobuf::SingularPtrField<Stream>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Event {
    pub fn new() -> Event {
        ::std::default::Default::default()
    }

    // .krpc.schema.Stream stream = 1;

    pub fn clear_stream(&mut self) {
        self.stream.clear();
    }

    pub fn has_stream(&self) -> bool {
        self.stream.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stream(&mut self, v: Stream) {
        self.stream = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stream(&mut self) -> &mut Stream {
        if self.stream.is_none() {
            self.stream.set_default();
        }
        self.stream.as_mut().unwrap()
    }

    // Take field
    pub fn take_stream(&mut self) -> Stream {
        self.stream.take().unwrap_or_else(|| Stream::new())
    }

    pub fn get_stream(&self) -> &Stream {
        self.stream.as_ref().unwrap_or_else(|| Stream::default_instance())
    }
}

impl ::protobuf::Message for Event {
    fn is_initialized(&self) -> bool {
        for v in &self.stream {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stream)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.stream.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.stream.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Event {
        Event::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Stream>>(
                    "stream",
                    |m: &Event| { &m.stream },
                    |m: &mut Event| { &mut m.stream },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Event>(
                    "Event",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Event {
        static mut instance: ::protobuf::lazy::Lazy<Event> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Event,
        };
        unsafe {
            instance.get(Event::new)
        }
    }
}

impl ::protobuf::Clear for Event {
    fn clear(&mut self) {
        self.clear_stream();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Event {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Event {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Status {
    // message fields
    pub version: ::std::string::String,
    pub bytes_read: u64,
    pub bytes_written: u64,
    pub bytes_read_rate: f32,
    pub bytes_written_rate: f32,
    pub rpcs_executed: u64,
    pub rpc_rate: f32,
    pub one_rpc_per_update: bool,
    pub max_time_per_update: u32,
    pub adaptive_rate_control: bool,
    pub blocking_recv: bool,
    pub recv_timeout: u32,
    pub time_per_rpc_update: f32,
    pub poll_time_per_rpc_update: f32,
    pub exec_time_per_rpc_update: f32,
    pub stream_rpcs: u32,
    pub stream_rpcs_executed: u64,
    pub stream_rpc_rate: f32,
    pub time_per_stream_update: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Status {
    pub fn new() -> Status {
        ::std::default::Default::default()
    }

    // string version = 1;

    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }

    pub fn get_version(&self) -> &str {
        &self.version
    }

    // uint64 bytes_read = 2;

    pub fn clear_bytes_read(&mut self) {
        self.bytes_read = 0;
    }

    // Param is passed by value, moved
    pub fn set_bytes_read(&mut self, v: u64) {
        self.bytes_read = v;
    }

    pub fn get_bytes_read(&self) -> u64 {
        self.bytes_read
    }

    // uint64 bytes_written = 3;

    pub fn clear_bytes_written(&mut self) {
        self.bytes_written = 0;
    }

    // Param is passed by value, moved
    pub fn set_bytes_written(&mut self, v: u64) {
        self.bytes_written = v;
    }

    pub fn get_bytes_written(&self) -> u64 {
        self.bytes_written
    }

    // float bytes_read_rate = 4;

    pub fn clear_bytes_read_rate(&mut self) {
        self.bytes_read_rate = 0.;
    }

    // Param is passed by value, moved
    pub fn set_bytes_read_rate(&mut self, v: f32) {
        self.bytes_read_rate = v;
    }

    pub fn get_bytes_read_rate(&self) -> f32 {
        self.bytes_read_rate
    }

    // float bytes_written_rate = 5;

    pub fn clear_bytes_written_rate(&mut self) {
        self.bytes_written_rate = 0.;
    }

    // Param is passed by value, moved
    pub fn set_bytes_written_rate(&mut self, v: f32) {
        self.bytes_written_rate = v;
    }

    pub fn get_bytes_written_rate(&self) -> f32 {
        self.bytes_written_rate
    }

    // uint64 rpcs_executed = 6;

    pub fn clear_rpcs_executed(&mut self) {
        self.rpcs_executed = 0;
    }

    // Param is passed by value, moved
    pub fn set_rpcs_executed(&mut self, v: u64) {
        self.rpcs_executed = v;
    }

    pub fn get_rpcs_executed(&self) -> u64 {
        self.rpcs_executed
    }

    // float rpc_rate = 7;

    pub fn clear_rpc_rate(&mut self) {
        self.rpc_rate = 0.;
    }

    // Param is passed by value, moved
    pub fn set_rpc_rate(&mut self, v: f32) {
        self.rpc_rate = v;
    }

    pub fn get_rpc_rate(&self) -> f32 {
        self.rpc_rate
    }

    // bool one_rpc_per_update = 8;

    pub fn clear_one_rpc_per_update(&mut self) {
        self.one_rpc_per_update = false;
    }

    // Param is passed by value, moved
    pub fn set_one_rpc_per_update(&mut self, v: bool) {
        self.one_rpc_per_update = v;
    }

    pub fn get_one_rpc_per_update(&self) -> bool {
        self.one_rpc_per_update
    }

    // uint32 max_time_per_update = 9;

    pub fn clear_max_time_per_update(&mut self) {
        self.max_time_per_update = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_time_per_update(&mut self, v: u32) {
        self.max_time_per_update = v;
    }

    pub fn get_max_time_per_update(&self) -> u32 {
        self.max_time_per_update
    }

    // bool adaptive_rate_control = 10;

    pub fn clear_adaptive_rate_control(&mut self) {
        self.adaptive_rate_control = false;
    }

    // Param is passed by value, moved
    pub fn set_adaptive_rate_control(&mut self, v: bool) {
        self.adaptive_rate_control = v;
    }

    pub fn get_adaptive_rate_control(&self) -> bool {
        self.adaptive_rate_control
    }

    // bool blocking_recv = 11;

    pub fn clear_blocking_recv(&mut self) {
        self.blocking_recv = false;
    }

    // Param is passed by value, moved
    pub fn set_blocking_recv(&mut self, v: bool) {
        self.blocking_recv = v;
    }

    pub fn get_blocking_recv(&self) -> bool {
        self.blocking_recv
    }

    // uint32 recv_timeout = 12;

    pub fn clear_recv_timeout(&mut self) {
        self.recv_timeout = 0;
    }

    // Param is passed by value, moved
    pub fn set_recv_timeout(&mut self, v: u32) {
        self.recv_timeout = v;
    }

    pub fn get_recv_timeout(&self) -> u32 {
        self.recv_timeout
    }

    // float time_per_rpc_update = 13;

    pub fn clear_time_per_rpc_update(&mut self) {
        self.time_per_rpc_update = 0.;
    }

    // Param is passed by value, moved
    pub fn set_time_per_rpc_update(&mut self, v: f32) {
        self.time_per_rpc_update = v;
    }

    pub fn get_time_per_rpc_update(&self) -> f32 {
        self.time_per_rpc_update
    }

    // float poll_time_per_rpc_update = 14;

    pub fn clear_poll_time_per_rpc_update(&mut self) {
        self.poll_time_per_rpc_update = 0.;
    }

    // Param is passed by value, moved
    pub fn set_poll_time_per_rpc_update(&mut self, v: f32) {
        self.poll_time_per_rpc_update = v;
    }

    pub fn get_poll_time_per_rpc_update(&self) -> f32 {
        self.poll_time_per_rpc_update
    }

    // float exec_time_per_rpc_update = 15;

    pub fn clear_exec_time_per_rpc_update(&mut self) {
        self.exec_time_per_rpc_update = 0.;
    }

    // Param is passed by value, moved
    pub fn set_exec_time_per_rpc_update(&mut self, v: f32) {
        self.exec_time_per_rpc_update = v;
    }

    pub fn get_exec_time_per_rpc_update(&self) -> f32 {
        self.exec_time_per_rpc_update
    }

    // uint32 stream_rpcs = 16;

    pub fn clear_stream_rpcs(&mut self) {
        self.stream_rpcs = 0;
    }

    // Param is passed by value, moved
    pub fn set_stream_rpcs(&mut self, v: u32) {
        self.stream_rpcs = v;
    }

    pub fn get_stream_rpcs(&self) -> u32 {
        self.stream_rpcs
    }

    // uint64 stream_rpcs_executed = 17;

    pub fn clear_stream_rpcs_executed(&mut self) {
        self.stream_rpcs_executed = 0;
    }

    // Param is passed by value, moved
    pub fn set_stream_rpcs_executed(&mut self, v: u64) {
        self.stream_rpcs_executed = v;
    }

    pub fn get_stream_rpcs_executed(&self) -> u64 {
        self.stream_rpcs_executed
    }

    // float stream_rpc_rate = 18;

    pub fn clear_stream_rpc_rate(&mut self) {
        self.stream_rpc_rate = 0.;
    }

    // Param is passed by value, moved
    pub fn set_stream_rpc_rate(&mut self, v: f32) {
        self.stream_rpc_rate = v;
    }

    pub fn get_stream_rpc_rate(&self) -> f32 {
        self.stream_rpc_rate
    }

    // float time_per_stream_update = 19;

    pub fn clear_time_per_stream_update(&mut self) {
        self.time_per_stream_update = 0.;
    }

    // Param is passed by value, moved
    pub fn set_time_per_stream_update(&mut self, v: f32) {
        self.time_per_stream_update = v;
    }

    pub fn get_time_per_stream_update(&self) -> f32 {
        self.time_per_stream_update
    }
}

impl ::protobuf::Message for Status {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.bytes_read = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.bytes_written = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.bytes_read_rate = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.bytes_written_rate = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.rpcs_executed = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.rpc_rate = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.one_rpc_per_update = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_time_per_update = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.adaptive_rate_control = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.blocking_recv = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.recv_timeout = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.time_per_rpc_update = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.poll_time_per_rpc_update = tmp;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.exec_time_per_rpc_update = tmp;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.stream_rpcs = tmp;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.stream_rpcs_executed = tmp;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.stream_rpc_rate = tmp;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.time_per_stream_update = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.version);
        }
        if self.bytes_read != 0 {
            my_size += ::protobuf::rt::value_size(2, self.bytes_read, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.bytes_written != 0 {
            my_size += ::protobuf::rt::value_size(3, self.bytes_written, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.bytes_read_rate != 0. {
            my_size += 5;
        }
        if self.bytes_written_rate != 0. {
            my_size += 5;
        }
        if self.rpcs_executed != 0 {
            my_size += ::protobuf::rt::value_size(6, self.rpcs_executed, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rpc_rate != 0. {
            my_size += 5;
        }
        if self.one_rpc_per_update != false {
            my_size += 2;
        }
        if self.max_time_per_update != 0 {
            my_size += ::protobuf::rt::value_size(9, self.max_time_per_update, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.adaptive_rate_control != false {
            my_size += 2;
        }
        if self.blocking_recv != false {
            my_size += 2;
        }
        if self.recv_timeout != 0 {
            my_size += ::protobuf::rt::value_size(12, self.recv_timeout, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.time_per_rpc_update != 0. {
            my_size += 5;
        }
        if self.poll_time_per_rpc_update != 0. {
            my_size += 5;
        }
        if self.exec_time_per_rpc_update != 0. {
            my_size += 5;
        }
        if self.stream_rpcs != 0 {
            my_size += ::protobuf::rt::value_size(16, self.stream_rpcs, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.stream_rpcs_executed != 0 {
            my_size += ::protobuf::rt::value_size(17, self.stream_rpcs_executed, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.stream_rpc_rate != 0. {
            my_size += 6;
        }
        if self.time_per_stream_update != 0. {
            my_size += 6;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.version.is_empty() {
            os.write_string(1, &self.version)?;
        }
        if self.bytes_read != 0 {
            os.write_uint64(2, self.bytes_read)?;
        }
        if self.bytes_written != 0 {
            os.write_uint64(3, self.bytes_written)?;
        }
        if self.bytes_read_rate != 0. {
            os.write_float(4, self.bytes_read_rate)?;
        }
        if self.bytes_written_rate != 0. {
            os.write_float(5, self.bytes_written_rate)?;
        }
        if self.rpcs_executed != 0 {
            os.write_uint64(6, self.rpcs_executed)?;
        }
        if self.rpc_rate != 0. {
            os.write_float(7, self.rpc_rate)?;
        }
        if self.one_rpc_per_update != false {
            os.write_bool(8, self.one_rpc_per_update)?;
        }
        if self.max_time_per_update != 0 {
            os.write_uint32(9, self.max_time_per_update)?;
        }
        if self.adaptive_rate_control != false {
            os.write_bool(10, self.adaptive_rate_control)?;
        }
        if self.blocking_recv != false {
            os.write_bool(11, self.blocking_recv)?;
        }
        if self.recv_timeout != 0 {
            os.write_uint32(12, self.recv_timeout)?;
        }
        if self.time_per_rpc_update != 0. {
            os.write_float(13, self.time_per_rpc_update)?;
        }
        if self.poll_time_per_rpc_update != 0. {
            os.write_float(14, self.poll_time_per_rpc_update)?;
        }
        if self.exec_time_per_rpc_update != 0. {
            os.write_float(15, self.exec_time_per_rpc_update)?;
        }
        if self.stream_rpcs != 0 {
            os.write_uint32(16, self.stream_rpcs)?;
        }
        if self.stream_rpcs_executed != 0 {
            os.write_uint64(17, self.stream_rpcs_executed)?;
        }
        if self.stream_rpc_rate != 0. {
            os.write_float(18, self.stream_rpc_rate)?;
        }
        if self.time_per_stream_update != 0. {
            os.write_float(19, self.time_per_stream_update)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Status {
        Status::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "version",
                    |m: &Status| { &m.version },
                    |m: &mut Status| { &mut m.version },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "bytes_read",
                    |m: &Status| { &m.bytes_read },
                    |m: &mut Status| { &mut m.bytes_read },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "bytes_written",
                    |m: &Status| { &m.bytes_written },
                    |m: &mut Status| { &mut m.bytes_written },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "bytes_read_rate",
                    |m: &Status| { &m.bytes_read_rate },
                    |m: &mut Status| { &mut m.bytes_read_rate },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "bytes_written_rate",
                    |m: &Status| { &m.bytes_written_rate },
                    |m: &mut Status| { &mut m.bytes_written_rate },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "rpcs_executed",
                    |m: &Status| { &m.rpcs_executed },
                    |m: &mut Status| { &mut m.rpcs_executed },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "rpc_rate",
                    |m: &Status| { &m.rpc_rate },
                    |m: &mut Status| { &mut m.rpc_rate },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "one_rpc_per_update",
                    |m: &Status| { &m.one_rpc_per_update },
                    |m: &mut Status| { &mut m.one_rpc_per_update },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "max_time_per_update",
                    |m: &Status| { &m.max_time_per_update },
                    |m: &mut Status| { &mut m.max_time_per_update },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "adaptive_rate_control",
                    |m: &Status| { &m.adaptive_rate_control },
                    |m: &mut Status| { &mut m.adaptive_rate_control },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "blocking_recv",
                    |m: &Status| { &m.blocking_recv },
                    |m: &mut Status| { &mut m.blocking_recv },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "recv_timeout",
                    |m: &Status| { &m.recv_timeout },
                    |m: &mut Status| { &mut m.recv_timeout },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "time_per_rpc_update",
                    |m: &Status| { &m.time_per_rpc_update },
                    |m: &mut Status| { &mut m.time_per_rpc_update },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "poll_time_per_rpc_update",
                    |m: &Status| { &m.poll_time_per_rpc_update },
                    |m: &mut Status| { &mut m.poll_time_per_rpc_update },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "exec_time_per_rpc_update",
                    |m: &Status| { &m.exec_time_per_rpc_update },
                    |m: &mut Status| { &mut m.exec_time_per_rpc_update },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "stream_rpcs",
                    |m: &Status| { &m.stream_rpcs },
                    |m: &mut Status| { &mut m.stream_rpcs },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "stream_rpcs_executed",
                    |m: &Status| { &m.stream_rpcs_executed },
                    |m: &mut Status| { &mut m.stream_rpcs_executed },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "stream_rpc_rate",
                    |m: &Status| { &m.stream_rpc_rate },
                    |m: &mut Status| { &mut m.stream_rpc_rate },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "time_per_stream_update",
                    |m: &Status| { &m.time_per_stream_update },
                    |m: &mut Status| { &mut m.time_per_stream_update },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Status>(
                    "Status",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Status {
        static mut instance: ::protobuf::lazy::Lazy<Status> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Status,
        };
        unsafe {
            instance.get(Status::new)
        }
    }
}

impl ::protobuf::Clear for Status {
    fn clear(&mut self) {
        self.clear_version();
        self.clear_bytes_read();
        self.clear_bytes_written();
        self.clear_bytes_read_rate();
        self.clear_bytes_written_rate();
        self.clear_rpcs_executed();
        self.clear_rpc_rate();
        self.clear_one_rpc_per_update();
        self.clear_max_time_per_update();
        self.clear_adaptive_rate_control();
        self.clear_blocking_recv();
        self.clear_recv_timeout();
        self.clear_time_per_rpc_update();
        self.clear_poll_time_per_rpc_update();
        self.clear_exec_time_per_rpc_update();
        self.clear_stream_rpcs();
        self.clear_stream_rpcs_executed();
        self.clear_stream_rpc_rate();
        self.clear_time_per_stream_update();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Status {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Status {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiplexedRequest {
    // message fields
    pub connection_request: ::protobuf::SingularPtrField<ConnectionRequest>,
    pub request: ::protobuf::SingularPtrField<Request>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MultiplexedRequest {
    pub fn new() -> MultiplexedRequest {
        ::std::default::Default::default()
    }

    // .krpc.schema.ConnectionRequest connection_request = 1;

    pub fn clear_connection_request(&mut self) {
        self.connection_request.clear();
    }

    pub fn has_connection_request(&self) -> bool {
        self.connection_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connection_request(&mut self, v: ConnectionRequest) {
        self.connection_request = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connection_request(&mut self) -> &mut ConnectionRequest {
        if self.connection_request.is_none() {
            self.connection_request.set_default();
        }
        self.connection_request.as_mut().unwrap()
    }

    // Take field
    pub fn take_connection_request(&mut self) -> ConnectionRequest {
        self.connection_request.take().unwrap_or_else(|| ConnectionRequest::new())
    }

    pub fn get_connection_request(&self) -> &ConnectionRequest {
        self.connection_request.as_ref().unwrap_or_else(|| ConnectionRequest::default_instance())
    }

    // .krpc.schema.Request request = 2;

    pub fn clear_request(&mut self) {
        self.request.clear();
    }

    pub fn has_request(&self) -> bool {
        self.request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request(&mut self, v: Request) {
        self.request = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_request(&mut self) -> &mut Request {
        if self.request.is_none() {
            self.request.set_default();
        }
        self.request.as_mut().unwrap()
    }

    // Take field
    pub fn take_request(&mut self) -> Request {
        self.request.take().unwrap_or_else(|| Request::new())
    }

    pub fn get_request(&self) -> &Request {
        self.request.as_ref().unwrap_or_else(|| Request::default_instance())
    }
}

impl ::protobuf::Message for MultiplexedRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.connection_request {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.request {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.connection_request)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.request)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.connection_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.connection_request.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.request.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiplexedRequest {
        MultiplexedRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ConnectionRequest>>(
                    "connection_request",
                    |m: &MultiplexedRequest| { &m.connection_request },
                    |m: &mut MultiplexedRequest| { &mut m.connection_request },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Request>>(
                    "request",
                    |m: &MultiplexedRequest| { &m.request },
                    |m: &mut MultiplexedRequest| { &mut m.request },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MultiplexedRequest>(
                    "MultiplexedRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MultiplexedRequest {
        static mut instance: ::protobuf::lazy::Lazy<MultiplexedRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MultiplexedRequest,
        };
        unsafe {
            instance.get(MultiplexedRequest::new)
        }
    }
}

impl ::protobuf::Clear for MultiplexedRequest {
    fn clear(&mut self) {
        self.clear_connection_request();
        self.clear_request();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiplexedRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiplexedRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MultiplexedResponse {
    // message fields
    pub response: ::protobuf::SingularPtrField<Response>,
    pub stream_update: ::protobuf::SingularPtrField<StreamUpdate>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl MultiplexedResponse {
    pub fn new() -> MultiplexedResponse {
        ::std::default::Default::default()
    }

    // .krpc.schema.Response response = 1;

    pub fn clear_response(&mut self) {
        self.response.clear();
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: Response) {
        self.response = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_response(&mut self) -> &mut Response {
        if self.response.is_none() {
            self.response.set_default();
        }
        self.response.as_mut().unwrap()
    }

    // Take field
    pub fn take_response(&mut self) -> Response {
        self.response.take().unwrap_or_else(|| Response::new())
    }

    pub fn get_response(&self) -> &Response {
        self.response.as_ref().unwrap_or_else(|| Response::default_instance())
    }

    // .krpc.schema.StreamUpdate stream_update = 2;

    pub fn clear_stream_update(&mut self) {
        self.stream_update.clear();
    }

    pub fn has_stream_update(&self) -> bool {
        self.stream_update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stream_update(&mut self, v: StreamUpdate) {
        self.stream_update = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stream_update(&mut self) -> &mut StreamUpdate {
        if self.stream_update.is_none() {
            self.stream_update.set_default();
        }
        self.stream_update.as_mut().unwrap()
    }

    // Take field
    pub fn take_stream_update(&mut self) -> StreamUpdate {
        self.stream_update.take().unwrap_or_else(|| StreamUpdate::new())
    }

    pub fn get_stream_update(&self) -> &StreamUpdate {
        self.stream_update.as_ref().unwrap_or_else(|| StreamUpdate::default_instance())
    }
}

impl ::protobuf::Message for MultiplexedResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.response {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stream_update {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.response)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stream_update)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.response.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.stream_update.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.response.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.stream_update.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MultiplexedResponse {
        MultiplexedResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Response>>(
                    "response",
                    |m: &MultiplexedResponse| { &m.response },
                    |m: &mut MultiplexedResponse| { &mut m.response },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StreamUpdate>>(
                    "stream_update",
                    |m: &MultiplexedResponse| { &m.stream_update },
                    |m: &mut MultiplexedResponse| { &mut m.stream_update },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MultiplexedResponse>(
                    "MultiplexedResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MultiplexedResponse {
        static mut instance: ::protobuf::lazy::Lazy<MultiplexedResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MultiplexedResponse,
        };
        unsafe {
            instance.get(MultiplexedResponse::new)
        }
    }
}

impl ::protobuf::Clear for MultiplexedResponse {
    fn clear(&mut self) {
        self.clear_response();
        self.clear_stream_update();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MultiplexedResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiplexedResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\nkrpc.proto\x12\x0bkrpc.schema\"\xa3\x01\n\x11ConnectionRequest\x125\
    \n\x04type\x18\x01\x20\x01(\x0e2#.krpc.schema.ConnectionRequest.TypeB\
    \x02\x18\0\x12\x17\n\x0bclient_name\x18\x02\x20\x01(\tB\x02\x18\0\x12\
    \x1d\n\x11client_identifier\x18\x03\x20\x01(\x0cB\x02\x18\0\"\x1f\n\x04T\
    ype\x12\x07\n\x03RPC\x10\0\x12\n\n\x06STREAM\x10\x01\x1a\x02\x10\0\"\xce\
    \x01\n\x12ConnectionResponse\x12:\n\x06status\x18\x01\x20\x01(\x0e2&.krp\
    c.schema.ConnectionResponse.StatusB\x02\x18\0\x12\x13\n\x07message\x18\
    \x02\x20\x01(\tB\x02\x18\0\x12\x1d\n\x11client_identifier\x18\x03\x20\
    \x01(\x0cB\x02\x18\0\"H\n\x06Status\x12\x06\n\x02OK\x10\0\x12\x15\n\x11M\
    ALFORMED_MESSAGE\x10\x01\x12\x0b\n\x07TIMEOUT\x10\x02\x12\x0e\n\nWRONG_T\
    YPE\x10\x03\x1a\x02\x10\0\"8\n\x07Request\x12-\n\x05calls\x18\x01\x20\
    \x03(\x0b2\x1a.krpc.schema.ProcedureCallB\x02\x18\0\"\x9b\x01\n\rProcedu\
    reCall\x12\x13\n\x07service\x18\x01\x20\x01(\tB\x02\x18\0\x12\x15\n\tpro\
    cedure\x18\x02\x20\x01(\tB\x02\x18\0\x12\x16\n\nservice_id\x18\x04\x20\
    \x01(\rB\x02\x18\0\x12\x18\n\x0cprocedure_id\x18\x05\x20\x01(\rB\x02\x18\
    \0\x12,\n\targuments\x18\x03\x20\x03(\x0b2\x15.krpc.schema.ArgumentB\x02\
    \x18\0\"3\n\x08Argument\x12\x14\n\x08position\x18\x01\x20\x01(\rB\x02\
    \x18\0\x12\x11\n\x05value\x18\x02\x20\x01(\x0cB\x02\x18\0\"d\n\x08Respon\
    se\x12%\n\x05error\x18\x01\x20\x01(\x0b2\x12.krpc.schema.ErrorB\x02\x18\
    \0\x121\n\x07results\x18\x02\x20\x03(\x0b2\x1c.krpc.schema.ProcedureResu\
    ltB\x02\x18\0\"K\n\x0fProcedureResult\x12%\n\x05error\x18\x01\x20\x01(\
    \x0b2\x12.krpc.schema.ErrorB\x02\x18\0\x12\x11\n\x05value\x18\x02\x20\
    \x01(\x0cB\x02\x18\0\"`\n\x05Error\x12\x13\n\x07service\x18\x01\x20\x01(\
    \tB\x02\x18\0\x12\x10\n\x04name\x18\x02\x20\x01(\tB\x02\x18\0\x12\x17\n\
    \x0bdescription\x18\x03\x20\x01(\tB\x02\x18\0\x12\x17\n\x0bstack_trace\
    \x18\x04\x20\x01(\tB\x02\x18\0\">\n\x0cStreamUpdate\x12.\n\x07results\
    \x18\x01\x20\x03(\x0b2\x19.krpc.schema.StreamResultB\x02\x18\0\"P\n\x0cS\
    treamResult\x12\x0e\n\x02id\x18\x01\x20\x01(\x04B\x02\x18\0\x120\n\x06re\
    sult\x18\x02\x20\x01(\x0b2\x1c.krpc.schema.ProcedureResultB\x02\x18\0\"6\
    \n\x08Services\x12*\n\x08services\x18\x01\x20\x03(\x0b2\x14.krpc.schema.\
    ServiceB\x02\x18\0\"\xf3\x01\n\x07Service\x12\x10\n\x04name\x18\x01\x20\
    \x01(\tB\x02\x18\0\x12.\n\nprocedures\x18\x02\x20\x03(\x0b2\x16.krpc.sch\
    ema.ProcedureB\x02\x18\0\x12'\n\x07classes\x18\x03\x20\x03(\x0b2\x12.krp\
    c.schema.ClassB\x02\x18\0\x122\n\x0cenumerations\x18\x04\x20\x03(\x0b2\
    \x18.krpc.schema.EnumerationB\x02\x18\0\x12.\n\nexceptions\x18\x05\x20\
    \x03(\x0b2\x16.krpc.schema.ExceptionB\x02\x18\0\x12\x19\n\rdocumentation\
    \x18\x06\x20\x01(\tB\x02\x18\0\"\xe9\x02\n\tProcedure\x12\x10\n\x04name\
    \x18\x01\x20\x01(\tB\x02\x18\0\x12.\n\nparameters\x18\x02\x20\x03(\x0b2\
    \x16.krpc.schema.ParameterB\x02\x18\0\x12*\n\x0breturn_type\x18\x03\x20\
    \x01(\x0b2\x11.krpc.schema.TypeB\x02\x18\0\x12\x1e\n\x12return_is_nullab\
    le\x18\x04\x20\x01(\x08B\x02\x18\0\x129\n\x0bgame_scenes\x18\x06\x20\x03\
    (\x0e2\x20.krpc.schema.Procedure.GameSceneB\x02\x18\0\x12\x19\n\rdocumen\
    tation\x18\x05\x20\x01(\tB\x02\x18\0\"x\n\tGameScene\x12\x10\n\x0cSPACE_\
    CENTER\x10\0\x12\n\n\x06FLIGHT\x10\x01\x12\x14\n\x10TRACKING_STATION\x10\
    \x02\x12\x0e\n\nEDITOR_VAB\x10\x03\x12\x0e\n\nEDITOR_SPH\x10\x04\x12\x13\
    \n\x0fMISSION_BUILDER\x10\x05\x1a\x02\x10\0\"]\n\tParameter\x12\x10\n\
    \x04name\x18\x01\x20\x01(\tB\x02\x18\0\x12#\n\x04type\x18\x02\x20\x01(\
    \x0b2\x11.krpc.schema.TypeB\x02\x18\0\x12\x19\n\rdefault_value\x18\x03\
    \x20\x01(\x0cB\x02\x18\0\"4\n\x05Class\x12\x10\n\x04name\x18\x01\x20\x01\
    (\tB\x02\x18\0\x12\x19\n\rdocumentation\x18\x02\x20\x01(\tB\x02\x18\0\"m\
    \n\x0bEnumeration\x12\x10\n\x04name\x18\x01\x20\x01(\tB\x02\x18\0\x121\n\
    \x06values\x18\x02\x20\x03(\x0b2\x1d.krpc.schema.EnumerationValueB\x02\
    \x18\0\x12\x19\n\rdocumentation\x18\x03\x20\x01(\tB\x02\x18\0\"R\n\x10En\
    umerationValue\x12\x10\n\x04name\x18\x01\x20\x01(\tB\x02\x18\0\x12\x11\n\
    \x05value\x18\x02\x20\x01(\x05B\x02\x18\0\x12\x19\n\rdocumentation\x18\
    \x03\x20\x01(\tB\x02\x18\0\"8\n\tException\x12\x10\n\x04name\x18\x01\x20\
    \x01(\tB\x02\x18\0\x12\x19\n\rdocumentation\x18\x02\x20\x01(\tB\x02\x18\
    \0\"\x9c\x03\n\x04Type\x12,\n\x04code\x18\x01\x20\x01(\x0e2\x1a.krpc.sch\
    ema.Type.TypeCodeB\x02\x18\0\x12\x13\n\x07service\x18\x02\x20\x01(\tB\
    \x02\x18\0\x12\x10\n\x04name\x18\x03\x20\x01(\tB\x02\x18\0\x12$\n\x05typ\
    es\x18\x04\x20\x03(\x0b2\x11.krpc.schema.TypeB\x02\x18\0\"\x98\x02\n\x08\
    TypeCode\x12\x08\n\x04NONE\x10\0\x12\n\n\x06DOUBLE\x10\x01\x12\t\n\x05FL\
    OAT\x10\x02\x12\n\n\x06SINT32\x10\x03\x12\n\n\x06SINT64\x10\x04\x12\n\n\
    \x06UINT32\x10\x05\x12\n\n\x06UINT64\x10\x06\x12\x08\n\x04BOOL\x10\x07\
    \x12\n\n\x06STRING\x10\x08\x12\t\n\x05BYTES\x10\t\x12\t\n\x05CLASS\x10d\
    \x12\x0f\n\x0bENUMERATION\x10e\x12\n\n\x05EVENT\x10\xc8\x01\x12\x13\n\
    \x0ePROCEDURE_CALL\x10\xc9\x01\x12\x0b\n\x06STREAM\x10\xca\x01\x12\x0b\n\
    \x06STATUS\x10\xcb\x01\x12\r\n\x08SERVICES\x10\xcc\x01\x12\n\n\x05TUPLE\
    \x10\xac\x02\x12\t\n\x04LIST\x10\xad\x02\x12\x08\n\x03SET\x10\xae\x02\
    \x12\x0f\n\nDICTIONARY\x10\xaf\x02\x1a\x02\x10\0\"\x1a\n\x05Tuple\x12\
    \x11\n\x05items\x18\x01\x20\x03(\x0cB\x02\x18\0\"\x19\n\x04List\x12\x11\
    \n\x05items\x18\x01\x20\x03(\x0cB\x02\x18\0\"\x18\n\x03Set\x12\x11\n\x05\
    items\x18\x01\x20\x03(\x0cB\x02\x18\0\"?\n\nDictionary\x121\n\x07entries\
    \x18\x01\x20\x03(\x0b2\x1c.krpc.schema.DictionaryEntryB\x02\x18\0\"5\n\
    \x0fDictionaryEntry\x12\x0f\n\x03key\x18\x01\x20\x01(\x0cB\x02\x18\0\x12\
    \x11\n\x05value\x18\x02\x20\x01(\x0cB\x02\x18\0\"\x18\n\x06Stream\x12\
    \x0e\n\x02id\x18\x01\x20\x01(\x04B\x02\x18\0\"0\n\x05Event\x12'\n\x06str\
    eam\x18\x01\x20\x01(\x0b2\x13.krpc.schema.StreamB\x02\x18\0\"\xc0\x04\n\
    \x06Status\x12\x13\n\x07version\x18\x01\x20\x01(\tB\x02\x18\0\x12\x16\n\
    \nbytes_read\x18\x02\x20\x01(\x04B\x02\x18\0\x12\x19\n\rbytes_written\
    \x18\x03\x20\x01(\x04B\x02\x18\0\x12\x1b\n\x0fbytes_read_rate\x18\x04\
    \x20\x01(\x02B\x02\x18\0\x12\x1e\n\x12bytes_written_rate\x18\x05\x20\x01\
    (\x02B\x02\x18\0\x12\x19\n\rrpcs_executed\x18\x06\x20\x01(\x04B\x02\x18\
    \0\x12\x14\n\x08rpc_rate\x18\x07\x20\x01(\x02B\x02\x18\0\x12\x1e\n\x12on\
    e_rpc_per_update\x18\x08\x20\x01(\x08B\x02\x18\0\x12\x1f\n\x13max_time_p\
    er_update\x18\t\x20\x01(\rB\x02\x18\0\x12!\n\x15adaptive_rate_control\
    \x18\n\x20\x01(\x08B\x02\x18\0\x12\x19\n\rblocking_recv\x18\x0b\x20\x01(\
    \x08B\x02\x18\0\x12\x18\n\x0crecv_timeout\x18\x0c\x20\x01(\rB\x02\x18\0\
    \x12\x1f\n\x13time_per_rpc_update\x18\r\x20\x01(\x02B\x02\x18\0\x12$\n\
    \x18poll_time_per_rpc_update\x18\x0e\x20\x01(\x02B\x02\x18\0\x12$\n\x18e\
    xec_time_per_rpc_update\x18\x0f\x20\x01(\x02B\x02\x18\0\x12\x17\n\x0bstr\
    eam_rpcs\x18\x10\x20\x01(\rB\x02\x18\0\x12\x20\n\x14stream_rpcs_executed\
    \x18\x11\x20\x01(\x04B\x02\x18\0\x12\x1b\n\x0fstream_rpc_rate\x18\x12\
    \x20\x01(\x02B\x02\x18\0\x12\"\n\x16time_per_stream_update\x18\x13\x20\
    \x01(\x02B\x02\x18\0\"\x7f\n\x12MultiplexedRequest\x12>\n\x12connection_\
    request\x18\x01\x20\x01(\x0b2\x1e.krpc.schema.ConnectionRequestB\x02\x18\
    \0\x12)\n\x07request\x18\x02\x20\x01(\x0b2\x14.krpc.schema.RequestB\x02\
    \x18\0\"x\n\x13MultiplexedResponse\x12+\n\x08response\x18\x01\x20\x01(\
    \x0b2\x15.krpc.schema.ResponseB\x02\x18\0\x124\n\rstream_update\x18\x02\
    \x20\x01(\x0b2\x19.krpc.schema.StreamUpdateB\x02\x18\0B\0b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
